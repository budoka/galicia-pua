import { LoadingOutlined } from '@ant-design/icons';
import { Button, Form, Popconfirm, Spin } from 'antd';
import React, { useCallback, useEffect, useState } from 'react';
import classNames from 'classnames';
import { TableComponents } from 'rc-table/lib/interface';
import './style.less';
import Table, { ColumnsType, ColumnType, TableProps } from 'antd/lib/table';
import { RootState } from 'src/reducers';
import { useSelector } from 'react-redux';
import { EditableCell, EditableCellProps } from './editable-cell';
import { IElement } from 'src/interfaces';
import styles from './style.module.less';
import { compare } from 'src/utils/string';

export type DataType = 'texto' | 'entero' | 'fecha' | 'boolean';
export type InputType = 'text' | 'select' | 'checkbox';

// Column extension
export interface IColumn<RecordType> extends ColumnType<RecordType> {
  forceEditing?: boolean;
  editable?: boolean;
  dataType?: DataType;
  inputType?: InputType;
  required?: boolean;
  length?: number;
  order?: number;
}

export interface EditableTableProps<RecordType> extends TableProps<RecordType> {
  hasIdColumn?: boolean;
  hasActionColumn?: boolean;
}

const idColumn = {
  key: 'id',
  dataIndex: 'id',
  title: 'ID',
  align: 'center',
  sorter: { compare: (a, b) => compare(a.id, b.id), multiple: -1 },
} as IColumn<any>;

const actionColumn = {
  key: 'actions',
  dataIndex: 'actions',
  title: 'Acciones',
  align: 'center',
} as IColumn<any>;

export const EditableTable = <RecordType extends IElement = IElement>(props: EditableTableProps<RecordType>) => {
  const [form] = Form.useForm();
  const [data, setData] = useState(props.dataSource ?? []);
  const [editingRows, setEditingRows] = useState<React.Key[]>([]);
  const [selectedRows, setSelectedRows] = useState<React.Key[]>([]);

  const buildColumns = (columns: ColumnsType<RecordType> | undefined) => {
    // console.log('building columns...');

    if (!columns || columns.length === 0) return;

    if (props.hasIdColumn) addColumn(idColumn, 'start');
    if (props.hasActionColumn) addColumn(actionColumn, 'end');

    columns = (columns as IColumn<RecordType>[]).map((col) => {
      return {
        ...col,
        render: col.render
          ? col.render
          : (value, record, index) => {
              if (col.key === 'id') return props.dataSource!.indexOf(record) + 1;
              else if (col.key === 'actions') return renderActions(record);
              else if (!value) return '-';
              else return value;
            },
        onCell: (record: RecordType) =>
          ({
            dataIndex: col.dataIndex,
            record,
            editing: col.forceEditing || isEditing(record),
            inputType: col.inputType,
            // title: col.title,
          } as EditableCellProps<RecordType>),
      } as IColumn<RecordType>;
    });

    console.table(columns);

    return columns;

    function addColumn(column: IColumn<RecordType>, addTo: 'start' | 'end') {
      console.log('addColumn: ' + addTo);

      if (addTo === 'start') columns = [column, ...columns!];
      else columns = [...columns!, column];
    }
  };

  /*const buildColumns = useCallback((columns: ColumnsType<RecordType> | undefined) => {
    // console.log('building columns...');

    if (!columns || columns.length === 0) return;

    if (props.hasIdColumn) addColumn(idColumn, 'start');
    if (props.hasActionColumn) addColumn(actionColumn, 'end');

    columns = (columns as IColumn<RecordType>[]).map((col) => {
      return {
        ...col,
        render: col.render
          ? col.render
          : (value, record, index) => {
              if (col.key === 'id') return props.dataSource!.indexOf(record) + 1;
              else if (col.key === 'actions') return renderActions(record);
              else if (!value) return '-';
              else return value;
            },
        onCell: (record: RecordType) =>
          ({
            dataIndex: col.dataIndex,
            record,
            editing: col.forceEditing || isEditing(record),
            inputType: col.inputType,
            // title: col.title,
          } as EditableCellProps<RecordType>),
      } as IColumn<RecordType>;
    });

    console.table(columns);

    return columns;

    function addColumn(column: IColumn<RecordType>, addTo: 'start' | 'end') {
      console.log('addColumn: ' + addTo);

      if (addTo === 'start') columns = [column, ...columns!];
      else columns = [...columns!, column];
    }
  }, []);*/

  const isEditing = (record: IElement) => {
    return editingRows.indexOf(record.id) > -1;
  };

  const edit = (record: IElement) => {
    console.log([...editingRows, record.key]);
    setEditingRows([...editingRows, record.key]);
    form.setFieldsValue({ ...record });
  };

  const cancel = () => {
    const [_, ...keys] = editingRows;
    setEditingRows(keys);
  };

  /*const save = async (key: React.Key) => {
    try {
      const row = (await form.validateFields()) as IElement;

      const newData = [...data];
      const index = newData.findIndex(element => key === element.id);
      if (index > -1) {
        const item = newData[index];
        newData.splice(index, 1, {
          ...item,
          ...row,
        });
        setData(newData);
        setEditingKey('');
      } else {
        newData.push(row);
        setData(newData);
        setEditingKey('');
      }
    } catch (errInfo) {
      console.log('Validate Failed:', errInfo);
    }
  };*/

  const renderTotal = (total: number) => {
    return `Total: ${total}`;
  };

  const renderActions = (record: RecordType) => {
    const renderButtonEdit = () => {
      return (
        <Button
          disabled={isEditing(record)}
          type="link"
          style={{ padding: 0, width: '50%' }}
          onClick={() => {
            edit(record);
          }}>
          Editar
        </Button>
      );
    };

    const renderButtonDelete = () => {
      return (
        <Popconfirm
          placement="left"
          disabled={isEditing(record)}
          title="¿Desea eliminar la fila?"
          onConfirm={() => {
            //    handleDeleteRecords([record.id]);
          }}
          okText="Sí"
          cancelText="No">
          <Button disabled={isEditing(record)} className={styles.buttonDelete} type="link" style={{ padding: 0, width: '50%' }}>
            Eliminar
          </Button>
        </Popconfirm>
      );
    };

    const renderButtonSave = () => {
      return (
        <Button
          className={styles.buttonSave}
          type="link"
          style={{ padding: 0, width: '50%' }}
          onClick={() => {
            // saveRow(record);
          }}>
          Guardar
        </Button>
      );
    };

    const renderButtonCancel = () => {
      return (
        <Button
          className={styles.buttonCancel}
          type="link"
          style={{ padding: 0, width: '50%' }}
          onClick={() => {
            //  cancelRow(record);
          }}>
          Cancelar
        </Button>
      );
    };

    const renderDivider = () => {
      return (
        <Button type="link" disabled style={{ cursor: 'default', color: 'gray', margin: 0, padding: 0 }}>
          |
        </Button>
      );
    };

    return isEditing(record) ? (
      <div className={styles.cellActions}>
        {renderButtonSave()} {renderDivider()} {renderButtonCancel()}
      </div>
    ) : (
      <div className={styles.cellActions}>
        {renderButtonEdit()} {renderDivider()} {renderButtonDelete()}
      </div>
    );
  };

  return (
    <div /*className={' unselectable'}*/>
      <Form form={form} component={false}>
        <Table
          {...props}
          components={{
            body: {
              cell: EditableCell,
            },
          }}
          pagination={{
            position: ['bottomCenter'],
            hideOnSinglePage: true,
            showTotal: (total, range) => renderTotal(total),
          }}
          columns={buildColumns(props.columns) as ColumnType<RecordType>[]}
        />
      </Form>
    </div>
  );
};
